Пролог / Контекст проекта RTP Cleaner
Зачем существует этот проект

Этот проект — proof-of-concept (POC) сервиса, который чинит некорректный RTP видеопоток (H264) в реальном времени.

Источник потока — домофон, который:

шлёт H264 over RTP,

нарушает RFC 6184,

из-за чего WebRTC клиенты принимают RTP, но дропают видео.

Проект не является продакшен-решением, его цель:

доказать, что поток можно починить “на лету”,

и интегрировать это в существующую SIP/WebRTC инфраструктуру без переписывания rtpengine или Kamailio.

Где сервис стоит в инфраструктуре

Типичный вызов:

Doorphone ⇄ Kamailio ⇄ RTP-cleaner ⇄ rtpengine ⇄ WebRTC client


RTP-cleaner вставляется только между домофоном и rtpengine

WebRTC клиент никогда не работает с RTP-cleaner напрямую

RTP-cleaner не знает ничего о SIP, SDP или WebRTC логике — только RTP

В чём именно была проблема RTP

При анализе реальных дампов (pcap) выяснилось:

1) Marker bit

marker (M=1) выставлялся:

на SPS/PPS,

в середине кадра,

несколько раз в одном access unit

WebRTC строго ожидает marker только на последнем RTP пакете кадра

2) Timestamp

одинаковые RTP timestamps использовались:

для разных кадров,

для SPS/PPS и предыдущего non-IDR кадра

это недопустимо для WebRTC и приводит к drop’у кадров

3) SPS/PPS и IDR

SPS/PPS могли приходить:

“между кадрами”,

с timestamp предыдущего кадра

WebRTC не может сопоставить такие SPS/PPS с последующим IDR и не начинает декодирование

Как проблема была воспроизведена и доказана

Для анализа использовался оффлайн подход:

Из проблемного pcap был извлечён H264 elementary stream

Этот поток был повторно отправлен как RTP через ffmpeg

Новый pcap показал:

корректные marker

корректные timestamp

Такой RTP успешно декодировался WebRTC клиентом

Далее была написана CLI-утилита, которая:

читала pcap,

чинила marker/timestamp/SPS-PPS,

генерировала “исправленный” pcap,

и подтверждала, что WebRTC начинает декодирование.

Live-сервис является прямым развитием этой оффлайн логики.

Что именно делает RTP-cleaner

RTP-cleaner не декодирует видео и не меняет кодек.

Он делает только следующее:

собирает RTP пакеты в access unit (кадр),

выставляет:

marker=1 только на последнем пакете кадра,

одинаковый timestamp на все пакеты кадра,

генерирует timestamps по wallclock,

буферизует SPS/PPS и привязывает их к корректному кадру,

проксирует аудио без изменений.

Ограничения и допущения (важно)

Это POC, не production

RTCP не используется (домофон его не поддерживает)

1 UDP порт на поток (RTP only)

Небольшая дополнительная задержка допустима (до ~150 ms)

Sequence numbers в базовой версии не перенумеровываются

Видео фикс применяется только на направлении домофон → rtpengine

Почему нельзя “просто проксировать RTP”

Даже если RTP проходит через Kamailio/rtpengine:

WebRTC принимает пакеты, но:

не декодирует,

считает поток некорректным,

silently drop’ает кадры

RTP-cleaner нужен именно как медиапрослойка, которая приводит RTP в состояние, приемлемое для WebRTC.

Что ожидается от реализации

Цель реализации — повторить в live-режиме ту же логику, которая уже доказала свою работоспособность на pcap:

минимальный буфер (1 кадр),

минимальная задержка,

корректные RTP semantics для H264.

Ключевая мысль (если читать только один абзац)

RTP-cleaner — это не “ещё один RTP proxy”.
Это H264-aware RTP normalizer, который исправляет ошибки домофона, из-за которых WebRTC не может декодировать видео.
